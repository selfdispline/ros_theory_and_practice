# 第四章作业

## 第一题：创建launch文件完成第3讲三道题目的启动和测试

### 第3讲第一题

创建turtle_pose_subscriber_vel_publisher.launch文件

```xml
<launch>
    <node pkg="turtlesim" type="turtlesim_node" name="turtlesim_node" />
    <node pkg="work_03" type="turtle_pose_subscriber_vel_publisher" name="turtle_pos_subscriber_vel_publisher" output="screen"/>
</launch>
```

### 第3讲第二题

创建my_turtle_spawn_client.launch文件

```xml
<launch>
    <node pkg="turtlesim" type="turtlesim_node" name="turtlesim_node" />
    <node pkg="work_03" type="my_turtle_spawn_client" name="my_turtle_spawn_client" output="screen" />
</launch>
```

### 第3讲第三题

创建turtle_motion_control.launch文件

```xml
<launch>
    <node pkg="turtlesim" type="turtlesim_node" name="turtlesim_node" />
    <node pkg="work_03" type="my_turtle_spawn_node" name="my_turtle_spawn_node" output="screen" />
    <node pkg="work_03" type="turtle_motion_control_node_2" name="turtle_motion_control_node_2" output="screen" />
</launch>
```

### 测试

```bash
#运行第1题launch文件
roslaunch learning_launch turtle_pose_subscriber_vel_publisher.launch
```

测试结果如下

![](第4章作业.assets/1-1.png)

```bash
#运行第2题launch文件
roslaunch learning_launch my_turtle_spawn_client.launch
```

测试结果如下

![](第4章作业.assets/1-2.png)

```bash
#运行第3题launch文件
roslaunch learning_launch turtle_motion_control.launch
#使用命令行发布/TurtleName话题消息，生成名为tu1的海龟
rostopic pub /TurtleName work_03/TurtleNameMsg "name: 'tu1'"
#使用命令行发布/TurtleName话题消息，生成名为tu2的海龟
rostopic pub /TurtleName work_03/TurtleNameMsg "name: 'tu2'"
#使用命令行发布/turtle_motion_cmd话题消息，启动海龟tu1的运动
rostopic pub /turtle_motion_cmd work_03/TurtleMotionCmdMsg "name: 'tu1'
start_move: true 
linear_velocity_x: 1.0
angular_velocity_z: 1.0" 
#使用命令行发布/turtle_motion_cmd话题消息，启动海龟tu2的运动
rostopic pub /turtle_motion_cmd work_03/TurtleMionCmdMsg "name: 'tu2'
start_move: true
linear_velocity_x: 2.0
angular_velocity_z: 1.0"

```

测试结果如下

![](第4章作业.assets/1-3.png)

测试过程录屏见work_04_1_video.mp4

## 第二题：gazebo测试

运行几个ros自带的gazebo例程测试gazebo

```bash
#运行mud_world.launch
roslaunch gazebo_ros mud_world.launch
```

![](第4章作业.assets/2-3.png)

```bash
#运行willowgarage_world
roslaunch gazebo_ros willowgarage_world.launch
```

![](第4章作业.assets/2-4.png)

在仿真场景中加入turtlebot机器人

![](第4章作业.assets/2-5.png)

## 第三题：tf编程测试

### 1 实现思路

​	（1）创建一个发布者，发布随机生成的激光雷达原始数据

​	（2）广播机器人底盘到激光雷达的坐标变换

​	（3）订阅激光雷达原始数据，并使用tf求解在底盘坐标系下的坐标值

### 2 程序实现

#### 	（1）激光雷达原始数据发布者——laser_data_publisher

```c++
//该节点用于生成模拟的激光雷达数据，并发布在/base_laser_data话题中
#include <ros/ros.h>
#include <geometry_msgs/PointStamped.h>

int main(int argc,char **argv)
{
    //初始化ROS节点
    ros::init(argc,argv,"laser_data_publisher");

    //创建节点句柄
    ros::NodeHandle n;
       
    //创建一个publisher,发布/base_laser_data话题，消息类型为geometry_msgs::PointStamped
    ros::Publisher laser_data_pub=n.advertise<geometry_msgs::PointStamped>("base_laser_data",10);
        
    //设置循环频率
    ros::Rate loop_rate(100);

    //初始化消息
   geometry_msgs::PointStamped laser_base_data;
    

    while(ros::ok())
    {    
        laser_base_data.header.stamp=ros::Time::now();
        laser_base_data.header.frame_id="base_laser";
        laser_base_data.point.x=rand()%100;
        laser_base_data.point.y=rand()%100;
        laser_base_data.point.z=rand()%100;
        
        //发布消息
        laser_data_pub.publish(laser_base_data);

        ROS_INFO("base_laser:(%.2f, %.2f. %.2f)  at time %.2f",
        laser_base_data.point.x,laser_base_data.point.y, laser_base_data.point.z,laser_base_data.header.stamp.toSec());      

        //循环延时
        loop_rate.sleep();
    }

    return 0;
}
```

#### （2）广播坐标变换——robot_tf_broadcaster

```c++
//该节点用于广播base_link到base_laser的坐标变换
#include <ros/ros.h>
#include <tf/transform_broadcaster.h>

int main(int argc, char** argv)
{
    ros::init(argc,argv,"robot_tf_broadcaster");
    ros::NodeHandle n;
    ros::Rate r(100);
    
    tf::TransformBroadcaster broadcaster;

    while(n.ok())
    {
        tf::Transform transform;
        transform.setOrigin(tf::Vector3(0.1,0,0.2));
        transform.setRotation(tf::Quaternion(0,0,0,1));

        broadcaster.sendTransform(
            tf::StampedTransform(transform,ros::Time::now(),"base_link", "base_laser"));           
        r.sleep();
    }
}
```

#### 	（3）监听坐标变换处理原始数据——robot_tf_listener

编程要点：每次订阅到原始数据回调函数内延迟10ms，以等待下一个tf数据，避免激光雷达原始数据时间戳在tf数据时间戳之后系统报错。

```c++
//该节点用于接收订阅/base_laser_data话题，并根据监听的tf将数据转化到base_link坐标系下
#include <ros/ros.h>
#include <geometry_msgs/PointStamped.h>
#include <tf/transform_listener.h>

tf::TransformListener* listener;

void base_laser_data_callback(const geometry_msgs::PointStamped::ConstPtr& base_laser_data)
{
    try
    {
        geometry_msgs::PointStamped base_link_data;
        ros::Rate r(100);
        r.sleep();
        listener->transformPoint("base_link", *base_laser_data, base_link_data);
        ROS_INFO("base_laser_data:(%.2f, %.2f, %.2f)time[%.2f]--------base_link_data:(%.2f, %.2f, %.2f)time[%.2f]",
        base_laser_data->point.x,base_laser_data->point.y,base_laser_data->point.z,base_laser_data->header.stamp.toSec(),
        base_link_data.point.x,base_link_data.point.y,base_link_data.point.z,base_link_data.header.stamp.toSec());

    }
    catch(tf::TransformException& ex)
    {
         ROS_ERROR("Received an exception trying to transform a point from \"base_laser\" to \"base_link\": %s", ex.what());
    }
    
}

int main(int argc,char **argv)
{
    //初始化ROS节点
    ros::init(argc,argv,"robot_tf_listener");

    //创建节点句柄
    ros::NodeHandle n;

    listener=new tf::TransformListener(ros::Duration(10));    

    //创建一个Subscriber,订阅/base_laser_data话题，消息类型为geometry_msgs::PointStamped
    ros::Subscriber base_laser_data_sub=n.subscribe("base_laser_data",100, base_laser_data_callback);      

    //等待订阅
    ros::spin();    
      
    return 0;
}
```

#### 	（4）launch文件

创建laser_to_base.launch文件启动上述三个节点

```xml
<launch>
    <node pkg="learning_tf" type="robot_tf_broadcaster" name="robot_tf_broadcaster" />
    <node pkg="learning_tf" type="robot_tf_listener" name="robot_tf_listener" output="screen" />
    <node pkg="learning_tf" type="laser_data_publisher" name="laser_data_publisher" />
</launch>
```

### 3 功能测试

```bash
#运行laser_to_base.launch
roslaunch learning_tf laser_to_base.launch
```

测试结果如下图所示，激光雷达在机器人底盘坐标系的数据转换正确

![](第4章作业.assets/3-1.png)

测试过程录屏见附件work_04_3.video

